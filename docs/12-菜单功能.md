# 菜单功能

## 翻译器
通过深层递归语言文件，按key路径查找翻译文本
```ts
// main/utils/index.ts

import logManager from '../service/LogService';

import en from '../../locales/en.json';
import zh from '../../locales/zh.json';

type MessageSchema = typeof zh;
const messages: Record<string, MessageSchema> = { en, zh }

export function createTranslator() {
  return (key?: string) => {
    if (!key) return void 0;
    try {
      const keys = key?.split('.'); // 例如 'menu.file' 分割为 ['menu', 'file']
      let result: any = messages['zh'];
    //   从默认语言（当前为 'zh'）的语言包中，按键路径逐层查找对应的翻译文本
      for (const _key of keys) {
        result = result[_key];
      }
      return result as string;
    } catch (e) {
      logManager.error('failed to translate key:', key, e);
      return key
    }
  }
}
```
用于菜单服务中：
```ts
// MenuService.ts
// 使用翻译器
let t: ReturnType<typeof createTranslator> = createTranslator();
```

## 日志服务更新
新增用户操作日志记录：
```ts
// logService.ts

public logUserOperation(operation: string, userId: string = 'unknown', details: any = {}): void {
    this.info(`User Operation: ${operation} by ${userId}, Details: ${JSON.stringify(details)}`);
  }
```

## `WindowService` 更新
实现窗口创建 / 关闭时的钩子机制，用于记录窗口状态变化。

### `_winStates`
是一个对象，存储每个窗口（按 windowName 区分）的状态信息。  
为每个窗口维护独立的生命周期回调队列，确保回调函数只针对特定窗口生效。
```ts
{
  [windowName]: {
    instance: BrowserWindow | void; // 窗口实例
    isHidden: boolean; // 是否隐藏
    onCreate: ((window: BrowserWindow) => void)[]; // 窗口创建时的回调队列
    onClosed: ((window: BrowserWindow) => void)[]; // 窗口关闭时的回调队列
  }
}
```

### `onWindowCreate/Close`：注册 / 删除窗口创建时的回调
允许外部代码注册一个函数，当指定名称的窗口被创建时，该函数会被触发。
```ts
public onWindowCreate(name: WindowNames, callback: (window: BrowserWindow) => void) {
  this._winStates[name].onCreate.push(callback); // 将回调添加到对应窗口的 onCreate 队列
}
```
 - 场景：例如在 main.ts 中，通过以下方式注册菜单，确保主窗口创建后立即初始化菜单。
 ```ts
 windowManager.onWindowCreate(WINDOW_NAMES.MAIN, registerMenus) 
 ```
 同理，`onWindowClose` 用于注册窗口关闭时的回调。例如窗口关闭时清理资源、保存状态等。


### 回调触发时机
窗口实例化并完成基础设置后，会遍历该窗口 `onCreate` 队列中的所有回调并执行：
```ts
// create()
this._winStates[name].onCreate.forEach(callback => callback(window));
```
此时窗口已创建但可能尚未加载内容，适合执行初始化逻辑（如注册菜单、绑定事件）。
同理，窗口销毁前会遍历 `onClosed` 队列中的所有回调并执行：
```ts
window.once('closed', () => {
  this._winStates[name].onClosed.forEach(callback => callback(window));
  // 后续清理窗口实例等操作
});
```


## 菜单内容

### 定义
定义了两种菜单：`CONVERSATION_LIST`（对话列表整体菜单）和 `CONVERSATION_ITEM`（单个对话项菜单），分别通过唯一 `menuId` 标识。  


### 注册
通过 `menuManager.register` 注册菜单模板：
 - 对话项菜单包含 “置顶” “重命名” “删除” 等操作。
 - 对话列表菜单包含 “新建对话” “排序方式” “批量操作” 等选项（排序包含子菜单，支持按创建时间、名称等排序）。
 - 每个菜单项通过 label 定义国际化键，后续通过翻译函数 t 转换为对应语言文本。


### 点击事件处理
 每个菜单项的 `click` 回调会触发 `logUserOperation` 记录操作日志，并通过 `window.webContents.send` 向渲染进程发送包含 `菜单 ID` 和 `操作 ID` 的事件。
 ```ts
// main/wins/main.ts

import type { BrowserWindow } from 'electron';
import { WINDOW_NAMES, MAIN_WIN_SIZE, IPC_EVENTS, MENU_IDS, CONVERSATION_ITEM_MENU_IDS, CONVERSATION_LIST_MENU_IDS } from '../../common/constants';
import { windowManager } from '../service/WindowService';
import { menuManager } from '../service/MenuService';
import { logManager } from '../service/LogService';


// 注册菜单
const registerMenus = (window: BrowserWindow) => {

  const conversationItemMenuItemClick = (id: string) => {
    logManager.logUserOperation(`${IPC_EVENTS.SHOW_CONTEXT_MENU}:${MENU_IDS.CONVERSATION_ITEM}-${id}`)
    // ipc事件传递cb，清楚具体点击了哪个item
    window.webContents.send(`${IPC_EVENTS.SHOW_CONTEXT_MENU}:${MENU_IDS.CONVERSATION_ITEM}`, id);
  }

  // 对话列表选项上注册菜单
  menuManager.register(MENU_IDS.CONVERSATION_ITEM, [
    {
      id: CONVERSATION_ITEM_MENU_IDS.PIN,
      label: 'menu.conversation.pinConversation',
      click: () => conversationItemMenuItemClick(CONVERSATION_ITEM_MENU_IDS.PIN)
    },
    {
      id: CONVERSATION_ITEM_MENU_IDS.RENAME,
      label: 'menu.conversation.renameConversation',
      click: () => conversationItemMenuItemClick(CONVERSATION_ITEM_MENU_IDS.RENAME)
    },
    {
      id: CONVERSATION_ITEM_MENU_IDS.DEL,
      label: 'menu.conversation.delConversation',
      click: () => conversationItemMenuItemClick(CONVERSATION_ITEM_MENU_IDS.DEL)
    },
  ])

  const conversationListMenuItemClick = (id: string) => {
    logManager.logUserOperation(`${IPC_EVENTS.SHOW_CONTEXT_MENU}:${MENU_IDS.CONVERSATION_LIST}-${id}`)
    window.webContents.send(`${IPC_EVENTS.SHOW_CONTEXT_MENU}:${MENU_IDS.CONVERSATION_LIST}`, id);
  }


  // 对话列表中注册菜单,注意区分对话列表和对话选项
  menuManager.register(MENU_IDS.CONVERSATION_LIST, [
    {
      id: CONVERSATION_LIST_MENU_IDS.NEW_CONVERSATION,
      label: 'menu.conversation.newConversation',
      click: () => conversationListMenuItemClick(CONVERSATION_LIST_MENU_IDS.NEW_CONVERSATION)
    },
    { type: 'separator' },
    {
      id: CONVERSATION_LIST_MENU_IDS.SORT_BY, label: 'menu.conversation.sortBy', submenu: [
        { id: CONVERSATION_LIST_MENU_IDS.SORT_BY_CREATE_TIME, label: 'menu.conversation.sortByCreateTime', type: 'radio', checked: false, click: () => conversationListMenuItemClick(CONVERSATION_LIST_MENU_IDS.SORT_BY_CREATE_TIME) },
        { id: CONVERSATION_LIST_MENU_IDS.SORT_BY_UPDATE_TIME, label: 'menu.conversation.sortByUpdateTime', type: 'radio', checked: false, click: () => conversationListMenuItemClick(CONVERSATION_LIST_MENU_IDS.SORT_BY_UPDATE_TIME) },
        { id: CONVERSATION_LIST_MENU_IDS.SORT_BY_NAME, label: 'menu.conversation.sortByName', type: 'radio', checked: false, click: () => conversationListMenuItemClick(CONVERSATION_LIST_MENU_IDS.SORT_BY_NAME) },
        { id: CONVERSATION_LIST_MENU_IDS.SORT_BY_MODEL, label: 'menu.conversation.sortByModel', type: 'radio', checked: false, click: () => conversationListMenuItemClick(CONVERSATION_LIST_MENU_IDS.SORT_BY_MODEL) },
        { type: 'separator' },
        { id: CONVERSATION_LIST_MENU_IDS.SORT_ASCENDING, label: 'menu.conversation.sortAscending', type: 'radio', checked: false, click: () => conversationListMenuItemClick(CONVERSATION_LIST_MENU_IDS.SORT_ASCENDING) },
        { id: CONVERSATION_LIST_MENU_IDS.SORT_DESCENDING, label: 'menu.conversation.sortDescending', type: 'radio', checked: false, click: () => conversationListMenuItemClick(CONVERSATION_LIST_MENU_IDS.SORT_DESCENDING) },
      ]
    },
    {
      id: CONVERSATION_LIST_MENU_IDS.BATCH_OPERATIONS,
      label: 'menu.conversation.batchOperations',
      click: () => conversationListMenuItemClick(CONVERSATION_LIST_MENU_IDS.BATCH_OPERATIONS)
    }
  ])
}

export function setupMainWindow() {
  windowManager.onWindowCreate(WINDOW_NAMES.MAIN, (mainWindow: any) => {
    registerMenus(mainWindow);
  });
  windowManager.create(WINDOW_NAMES.MAIN, MAIN_WIN_SIZE);
}
 ```


 ## 菜单显示与交互

 ### IPC 通信
 渲染进程通过 preload 暴露的 `window.api` 与主进程交互：
 - `showContextMenu`：调用主进程 `IPC_EVENTS.SHOW_CONTEXT_MENU` 事件，传入 `menuId` 和`动态配置`，触发菜单弹出。
 - `contextMenuItemClick`：监听主进程发送的菜单点击事件，获取用户点击的`菜单项 ID`。
```ts
// preload.ts

const api: WindowApi = {
    showContextMenu: (menuId: string, dynamicOptions?: string) => ipcRenderer.invoke(IPC_EVENTS.SHOW_CONTEXT_MENU, menuId, dynamicOptions),
    contextMenuItemClick: (menuId: string, cb: (id: string) => void) => ipcRenderer.on(`${IPC_EVENTS.SHOW_CONTEXT_MENU}:${menuId}`, (_, id) => cb(id)),
    removeContextMenuListener: (menuId: string)=> ipcRenderer.removeAllListeners(`${IPC_EVENTS.SHOW_CONTEXT_MENU}:${menuId}`),
}

```


### 菜单展示
在渲染进程中，右键点击元素、点击菜单项时，向主进程发送 IPC 请求，并且传入 menuId （指定菜单类型）和动态配置。  
主进程根据 menuId 查找预先注册的菜单模板，经过本地化处理后弹出菜单（await）。
```ts
// renderer/utils/ContextMenu.ts

import { MENU_IDS } from '../../common/constants';

export async function createContextMenu(menuId: MENU_IDS, cb?: (id: string) => void, dynamicOptions?: { label?: string, id: string, [key: string]: any }) {
  let result:string = '';
  window.api.contextMenuItemClick(menuId,id=>{
    cb?.(id);
    result = id;
  })
  await window.api.showContextMenu(menuId,JSON.stringify(dynamicOptions));

//   清理监听：菜单关闭后，移除事件监听避免内存泄漏。
  window.api.removeContextMenuListener(menuId);

  return result;
}
```


### 处理菜单点击
借助 `actionPolicy` 映射表（键为菜单项 id，值为处理函数），执行预设操作（如 “新建对话” 跳转路由、“删除” 打印日志等）。
```ts
// ConversationList/useContextMenu.ts

import { MENU_IDS, CONVERSATION_LIST_MENU_IDS } from '../../../common/constants';
import { createContextMenu } from '../../utils/contextMenu';
import { useConversationsStore } from '../../stores/conversations';


export function useContextMenu() {
  const router = useRouter();
  const route = useRoute();
  const conversationsStore = useConversationsStore();

  const actionPolicy = new Map([
    [CONVERSATION_LIST_MENU_IDS.BATCH_OPERATIONS, () => {
      console.log('batch operations');
    }],
    [CONVERSATION_LIST_MENU_IDS.NEW_CONVERSATION, () => {
      console.log('new conversation');
      router.push('/conversation')
    }],
    [CONVERSATION_LIST_MENU_IDS.SORT_BY_CREATE_TIME, () => {
      console.log('sort by create time');
    }
    ],
    [CONVERSATION_LIST_MENU_IDS.SORT_BY_UPDATE_TIME, () => {
      console.log('sort by update time');
    }
    ],
    [CONVERSATION_LIST_MENU_IDS.SORT_BY_NAME, () => {
      console.log('sort by name');
    }
    ],
    [CONVERSATION_LIST_MENU_IDS.SORT_BY_MODEL, () => {
      console.log('sort by model');
    }
    ],
    [CONVERSATION_LIST_MENU_IDS.SORT_DESCENDING, () => {
      console.log('sort descending');
    }],
    [CONVERSATION_LIST_MENU_IDS.SORT_ASCENDING, () => {
      console.log('sort ascending');
    }],
  ])

  const handle = async () => {

    const item = await createContextMenu(MENU_IDS.CONVERSATION_LIST, void 0);

    const action = actionPolicy.get(item as CONVERSATION_LIST_MENU_IDS);
    action?.();
  }

  return {
    handle
  }
}
```


### 组件使用菜单
 - 对话列表区域右键点击：触发 `handleListContextMenu` 函数，显示列表菜单 `MENU_IDS.CONVERSATION_LIST`。
 - 单个对话项右键点击：触发 `handleItemContextMenu` 函数，显示项级菜单 `MENU_IDS.CONVERSATION_ITEM`。
```vue
<!-- ConversationList/index.vue -->
<script setup lang="ts">

const conversationItemActionPolicy = new Map([
  [CONVERSATION_ITEM_MENU_IDS.DEL, () => {
    console.log('删除');
  }],
  [CONVERSATION_ITEM_MENU_IDS.RENAME, () => {
    console.log('重命名');
  }],
  [CONVERSATION_ITEM_MENU_IDS.PIN, () => {
    console.log('置顶');
  }],
])

const { handle: handleListContextMenu } = useContextMenu();

async function handleItemContextMenu(_item: Conversation) {
  const clickItem = await createContextMenu(MENU_IDS.CONVERSATION_ITEM, void 0) as CONVERSATION_ITEM_MENU_IDS;
  const action = conversationItemActionPolicy.get(clickItem);
  action && await action?.();
}

</script>

<template>
  <div @contextmenu.prevent.stop="handleListContextMenu">
    <search-bar/>
    <ul>
      <template v-for="item in conversations" :key="item.id">
        <li v-if="item.type !== 'divider'"
          @contextmenu.prevent.stop="handleItemContextMenu(item)">
          <list-item v-bind="item" />
        </li>
        <li v-else></li>
      </template>
    </ul>
  </div>
</template>
```
 - 搜索栏菜单按钮点击：直接调用 `handleListContextMenu`，显示列表菜单。
 ```vue
 <!-- ConversationList/SearchBar.vue -->
<script setup lang="ts">

const { handle: handleListContextMenu } = useContextMenu();
</script>

<template>
  <div @contextmenu.stop @click.stop>
    <n-input-group>
      <n-input>
        <template #prefix>
          <iconify-icon icon="material-symbols:search" />
        </template>
      </n-input>
      <n-input-group-label @click="handleListContextMenu">
        <n-icon>
          <iconify-icon icon="material-symbols:menu" />
        </n-icon>
      </n-input-group-label>
    </n-input-group>
  </div>
</template>
 ```