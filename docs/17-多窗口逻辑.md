# 多窗口
改造 `WindowService`，完善 `close` 和 `create` 逻辑。

## 改造 close
入口：
```ts
// really 是否真的关闭窗口（或者隐藏）
  public close(target: BrowserWindow | void | null, really: boolean = true) {
    if (!target) return;

    const name = this.getName(target);
    logManager.info(`Close window: ${name}, really: ${really}`);

    // 关闭逻辑（真假关闭）
    this._handleCloseWindowState(target, really);
  }
```
关闭逻辑：
```ts
// 关闭窗口方法
  private _handleCloseWindowState(target: BrowserWindow, really: boolean) {
    const name = this.getName(target) as WindowNames;

    if (name) {
      // 隐藏窗口
      if (!really) this._winStates[name].isHidden = true;
      // 删掉该窗口实例
      else this._winStates[name].instance = void 0;
    }

    setTimeout(() => {
      target[really ? 'close' : 'hide']?.();
      this._checkAndCloseAllWinodws();    // 检查
    }, 210)
  }


  private _checkAndCloseAllWinodws() {
    if (!this._winStates[WINDOW_NAMES.MAIN].instance || 
      this._winStates[WINDOW_NAMES.MAIN].instance?.isDestroyed())
      // 如果主窗口已关闭，则遍历其他窗口一起关闭
      return Object.values(this._winStates).forEach(win => win?.instance?.close());

    const minimizeToTray = false; // todo : 从配置中读取
    // 如果没有最小化，并且主窗口隐藏，则遍历其他窗口一起关闭（？）
    if (!minimizeToTray && !this.get(WINDOW_NAMES.MAIN)?.isVisible())
      return Object.values(this._winStates).forEach(win => !win?.instance?.isVisible() && win?.instance?.close());
  }
```


## 改造 create
入口：
```ts
public create(name: WindowNames, size: SizeOptions, moreOpts?: BrowserWindowConstructorOptions) {
    if (this.get(name)) return;    // 若已经有窗口实例，则不再创建
    const isHiddenWin = this._isHiddenWin(name);    // 获取隐藏窗口
    let window = this._createWinInstance(name, moreOpts);

    // 不是隐藏窗口时，加载生命周期和模板
    !isHiddenWin && this
      ._setupWinLifecycle(window, name)
      ._loadWindowTemplate(window, name)


    // 监听窗口准备阶段，若不是隐藏窗口，create时有loading；否则直接显示窗口
    this._listenWinReady({
      win: window,
      isHiddenWin,
      size
    })

    // 若没有隐藏窗口（未打开过），则打开并且记录实例
    if (!isHiddenWin) {
      this._winStates[name].instance = window;
      this._winStates[name].onCreate.forEach(callback => callback(window));
    }
    // 若隐藏（打开过），直接显示
    if (isHiddenWin) {
      this._winStates[name].isHidden = false;
      logManager.info(`Hidden window show: ${name}`)
    }

    return window;
  }
```
创建逻辑：
```ts
    // 判断窗口是否隐藏
  private _isHiddenWin(name: WindowNames) {
    return this._winStates[name] && this._winStates[name].isHidden;
  }


  // 创建窗口实例（有隐藏则返回隐藏实例，否则创建新实例）
  private _createWinInstance(name: WindowNames, opts?: BrowserWindowConstructorOptions) {
    return this._isHiddenWin(name)
      ? this._winStates[name].instance as BrowserWindow
      : new BrowserWindow({
        ...SHARED_WINDOW_OPTIONS,
        ...opts,
      });
  }


   // 监听窗口准备阶段
  private _listenWinReady(pararms: {
    win: BrowserWindow,
    isHiddenWin: boolean,
    size: SizeOptions,
  }) {
    const onReady = () => {
      // 设置窗口size
      pararms.win?.once('show', () => setTimeout(() => this._applySizeConstraints(pararms.win, pararms.size), 2));
      // 一切准备就绪再show
      pararms.win?.show();
    }

    // 若不是隐藏窗口（第一次打开），create时有loading；否则直接显示窗口
    if (!pararms.isHiddenWin) {
      const loadingHandler = this._addLoadingView(pararms.win, pararms.size);
      loadingHandler?.(onReady)
    } else {
      onReady();
    }
  }
```
loading 逻辑：
```ts
// 添加loading
  private _addLoadingView(window: BrowserWindow, size: SizeOptions) {
    let loadingView: WebContentsView | void = new WebContentsView();
    let rendererIsReady = false;   // 每次loading时重置状态

    // loading子视图
    window.contentView?.addChildView(loadingView);
    // loading全覆盖窗口
    loadingView.setBounds({
      x: 0,
      y: 0,
      width: size.width,
      height: size.height,
    });
    loadingView.webContents.loadFile(path.join(__dirname, 'loading.html'));  // loading源

    // 渲染准备阶段的检查
    const onRendererIsReady = (e: IpcMainEvent) => {
      // 发送者和当前window不同，或已经渲染完了，不再渲染
      if ((e.sender !== window?.webContents) || rendererIsReady) return;    
      rendererIsReady = true;
      window.contentView.removeChildView(loadingView as WebContentsView);
      ipcMain.removeListener(IPC_EVENTS.RENDERER_IS_READY, onRendererIsReady);
      loadingView = void 0;
    }
    // 等待ipc通信，渲染准备就绪再执行onRendererIsReady（ 下面的cb() ）
    ipcMain.on(IPC_EVENTS.RENDERER_IS_READY, onRendererIsReady);

    // loading完后
    return (cb: () => void) => loadingView?.webContents.once('dom-ready', () => {
      loadingView?.webContents.insertCSS(`body {
          background-color: ${themeManager.isDark ? '#2C2C2C' : '#FFFFFF'} !important; 
          --stop-color-start: ${themeManager.isDark ? '#A0A0A0' : '#7F7F7F'} !important;
          --stop-color-end: ${themeManager.isDark ? '#A0A0A0' : '#7F7F7F'} !important;
      }`);
      cb();  // loading准备好后callback
            // 例如点击托盘后显示loading图层，render就绪后再发送ipc移除loading
    })

  }
```

## 窗口操作主入口改造
```ts
// 窗口操作主入口（最大化、最小化、关闭）
  private _setupIpcEvents() {
    const handleCloseWindow = (e: IpcMainEvent) => {
      const target = BrowserWindow.fromWebContents(e.sender);
      const winName = this.getName(target);

      this.close(target, this._isReallyClose(winName));
    }
    // ...
  }
```

## loading 图层
```html
<!-- public/loading.html -->

<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Content-Security-Policy" content="script-src 'self';">
  <style>
    :root {
      --stop-color-start: #3b82f6;
      --stop-color-end: #1d4ed8;
    }

    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background-color: transparent;
    }
  </style>
</head>

<body>
  <svg width="30" height="30" viewBox="0 0 38 38" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="gradient" x1="8.042%" y1="0%" x2="65.682%" y2="23.865%">
        <stop stop-color="var(--stop-color-start)" offset="0%" />
        <stop stop-color="var(--stop-color-end)" offset="100%" />
      </linearGradient>
    </defs>
    <g fill="none" fill-rule="evenodd">
      <g transform="translate(1 1)" stroke-width="2">
        <circle stroke-opacity=".2" cx="18" cy="18" r="18" />
        <path d="M36 18c0-9.94-8.06-18-18-18" stroke="url(#gradient)">
          <animateTransform attributeName="transform" type="rotate" from="0 18 18" to="360 18 18" dur="1s"
            repeatCount="indefinite" />
        </path>
      </g>
    </g>
  </svg>
</body>

</html>
```
