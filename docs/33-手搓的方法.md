# 手搓的方法
这里主要区分手搓与官方库的使用场景与作用。

## 翻译器
手搓的翻译器主要用于主进程中，由于主进程不像渲染层需要动态传参，手写一个翻译器遍历语言包即可。
```ts
// main/utils/index.ts

export function createTranslator() {
  return (key?: string) => {
    if (!key) return void 0;
    try {
      const keys = key?.split('.'); // 例如 'menu.file' 分割为 ['menu', 'file']
      let result: any = messages[configManager.get(CONFIG_KEYS.LANGUAGE)];
    //   从默认语言（上一次保存）的语言包中，按键路径逐层查找对应的翻译文本
      for (const _key of keys) {
        result = result[_key];
      }
      return result as string;
    } catch (e) {
      logManager.error('failed to translate key:', key, e);
      return key
    }
  }
}
```

## Dialog
由于是多窗口应用，不同于单页面应用（SPA），前端资源是分开加载的，相当于多开了一个浏览器标签页；因此需要在渲染进程中单独创建窗口实例，完全是仿原生应用体验。
```ts
// renderer/hooks/useDialog.ts

export function useDialog() {
  const isDarkMode = usePreferredDark();

  const createDialog = (opts: CreateDialogProps) => {
    const overlay = document.createElement('div');
    const isModal = opts.isModal !== false;   // 默认展示遮罩层

    // 遮罩层样式
    overlay.classList.add('dialog-overlay');
    // 根据明暗，设置不同的bg-color
    watchEffect(() => overlay.style.backgroundColor = isDarkMode.value
      ? 'rgba(0, 0, 0, 0.6)'
      : 'rgba(255, 255, 255, 0.6)'
    );

    return new Promise<string>((resolve) => {

      // dialog交互后触发
      window.api.createDialog(opts).then(res => {
        resolve(res);
        if (!isModal) return;    // 没有遮罩层直接返回
        document.body.removeChild(overlay);   // 移除dom元素
        overlay?.classList?.remove('show');
      });

      // dialog创建后触发
      if (!isModal) return;
      document.body.appendChild(overlay);
      setTimeout(() => overlay.classList.add('show'), 10);
    });
  }
  return { createDialog }
}

export default useDialog;
```

## TimeAgo
手写 useTimeAgo，vueuse 的 useTimeAgo 时间久了不具体：具体见 26 章节