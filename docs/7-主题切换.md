# 主题切换

## ThemeService
主进程设置主题初始化实例：
```typescript
// main/services/ThemeService.ts
import { BrowserWindow, ipcMain, nativeTheme } from 'electron';
import { logManager } from './LogService';
import { IPC_EVENTS } from '@common/constants'

class ThemeService {
  private static _instance: ThemeService;
  private _isDark: boolean = nativeTheme.shouldUseDarkColors;

  constructor() {
    const themeMode = 'dark';
    if (themeMode) {
      nativeTheme.themeSource = themeMode;
      this._isDark = nativeTheme.shouldUseDarkColors;
    }
    this._setupIpcEvent();
    logManager.info('ThemeService initialized successfully.');
  }

  private _setupIpcEvent() {
    ipcMain.handle(IPC_EVENTS.SET_THEME_MODE, (_e, mode: ThemeMode) => {
      nativeTheme.themeSource = mode;
      return nativeTheme.shouldUseDarkColors;
    });
    ipcMain.handle(IPC_EVENTS.GET_THEME_MODE, () => {
      return nativeTheme.themeSource;
    });
    ipcMain.handle(IPC_EVENTS.IS_DARK_THEME, () => {
      return nativeTheme.shouldUseDarkColors;
    });
    // 发送主题切换信息给多个窗口
    nativeTheme.on('updated', () => {
      this._isDark = nativeTheme.shouldUseDarkColors;
      BrowserWindow.getAllWindows().forEach(win =>
        win.webContents.send(IPC_EVENTS.THEME_MODE_UPDATED, this._isDark)
      );
    });
  }
  public static getInstance() {
    if (!this._instance) {
      this._instance = new ThemeService();
    }
    return this._instance;
  }

  public get isDark() {
    return this._isDark;
  }

  public get themeMode() {
    return nativeTheme.themeSource;
  }
}

export const themeManager = ThemeService.getInstance();
export default themeManager;
```
也要在 `constants` 中添加主题枚举:
```ts
export enum IPC_EVENTS {
  // renderer to main
//   ...
  SET_THEME_MODE = 'set-theme-mode',
  GET_THEME_MODE = 'get-theme-mode',
  IS_DARK_THEME = 'is-dark-theme',


// log ...

  // main to renderer
  THEME_MODE_UPDATED = 'theme-mode-updated',
}
```

> themeManager 一定记得要在 main 进程中初始化，否则 ThemeService 不会在系统中实例化

在 `windowService` 中实例化主题:
```ts
const SHARED_WINDOW_OPTIONS = {

  darkTheme: themeManager.isDark,
  backgroundColor: themeManager.isDark ? '#2C2C2C' : '#FFFFFF',

} as BrowserWindowConstructorOptions;
```

## 主题切换
先在 global 定义类型
```ts
// global.d.ts

type ThemeMode = 'dark' | 'light' | 'system';

interface WindowApi {

  setThemeMode: (mode: ThemeMode) => Promise<boolean>;
  getThemeMode: () => Promise<ThemeMode>;
  isDarkTheme: () => Promise<boolean>;
  onSystemThemeChange: (callback: (isDark: boolean) => void) => void;

}
```
再 预加载脚本中定义好 api
```ts
// preload.ts

const api: WindowApi = {

  setThemeMode: (mode: ThemeMode) => ipcRenderer.invoke(IPC_EVENTS.SET_THEME_MODE, mode),
  getThemeMode: () => ipcRenderer.invoke(IPC_EVENTS.GET_THEME_MODE),
  isDarkTheme: () => ipcRenderer.invoke(IPC_EVENTS.IS_DARK_THEME),
  // 对应themeService的send发送窗口信息
  onSystemThemeChange: (callback: (isDark: boolean) => void) => ipcRenderer.on(IPC_EVENTS.THEME_MODE_UPDATED, (_, isDark) => callback(isDark)),
}
```
- 写一个通用的 hook，定义主题切换方法

```typescript
// renderer/hooks/useThemeMode.ts
const iconMap = new Map([
  ['system', 'material-symbols:auto-awesome-outline'],
  ['light', 'material-symbols:light-mode-outline'],
  ['dark', 'material-symbols:dark-mode-outline'],
])
export function useThemeMode() {
  const themeMode = ref<ThemeMode>('dark');
  const isDark = ref<boolean>(false);
  const themeIcon = computed(() => iconMap.get(themeMode.value) || 'material-symbols:auto-awesome-outline');

  const themeChangeCallbacks: Array<(mode: ThemeMode) => void> = [];

  function setThemeMode(mode: ThemeMode) {
    themeMode.value = mode;
    window.api.setThemeMode(mode);
  }
  function getThemeMode() {
    return themeMode.value;
  }

  function onThemeChange(callback: (mode: ThemeMode) => void) {

    // 主题更新后, 将所有更新方法放入数组中一一执行
    themeChangeCallbacks.push(callback);
  }

  onMounted(async () => {
  // 监听系统主题变化（主进程会实时推送系统主题是否为暗色）
  window.api.onSystemThemeChange((_isDark) => {
    // 从主进程获取当前应用的主题模式
    window.api.getThemeMode().then(res => {
      isDark.value = _isDark; // 同步系统的暗色状态
      if (res !== themeMode.value) themeMode.value = res; // 跟随系统主题
      // 触发所有外部注册的主题变更回调(所有更新方法)
      themeChangeCallbacks.forEach(cb => cb(res));
    });
  });

  // 2. 初始化：获取初始的系统暗色状态和应用主题模式
  isDark.value = await window.api.isDarkTheme(); // 主进程返回当前系统是否为暗色
  themeMode.value = await window.api.getThemeMode(); // 主进程返回已持久化的应用主题模式
});

  return {
    themeMode,
    themeIcon,
    isDark,
    setThemeMode,
    getThemeMode,
    onThemeChange,
  }
}

export default useThemeMode;
```

- 然后在 `NavBar` 中使用 `ThemeSwitcher` 主题按钮

```vue
<script setup lang="ts">
import { useThemeMode } from '@renderer/hooks/useThemeMode';
import { Icon as IconifyIcon } from '@iconify/vue';

defineOptions({ name: 'ThemeSwitcher' });

const {
  themeIcon,
  setThemeMode,
} = useThemeMode();
const isDarkMode = usePreferredDark();

function toggleThemeMode() {
  setThemeMode(isDarkMode.value ? 'light' : 'dark');
}
</script>

<template>
  <iconify-icon :icon="themeIcon" width="24" height="24" @click="toggleThemeMode" />
</template>
```