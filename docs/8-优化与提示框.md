# 优化与提示框

## i18n 优化
两个方法可以直接获取和修改当前语言：
```ts
// renderer/i18n.ts

export async function setLanguage(lang:LanguageType,_i18n?:I18n){
  const __i18n = _i18n ?? i18n;
  if(__i18n.mode === 'legacy'){
    __i18n.global.locale = lang;
    return;
  }
  (__i18n.global.locale as unknown as Ref<LanguageType>).value = lang;
}

export function getLanguage(){
  if(i18n.mode === 'legacy'){
    return i18n.global.locale;
  }
  return (i18n.global.locale as unknown as Ref<LanguageType>).value;
}
```
在配置插件i18n-ally，悬浮在语言文本上显示中英文：
```json
{
  "i18n-ally.localesPaths": [
    "locales"
  ],
  "i18n-ally.displayLanguage": "zh",
  "i18n-ally.keystyle": "nested"
}
```


## 提示框 NativeTooltip
由于 electron tooltip 需要和主进程联动，过于麻烦，于是自己写一个原生提示框。
```vue
<!-- renderer/components/NativeTooltip -->

<script setup lang="ts">
import { logger } from '../utils/logger'

// electron的tooltip要联动主进程，不太方便
interface Props {
  content: string;
}

defineOptions({ name: 'NativeTooltip' });

const props = defineProps<Props>();
//   若有内容被<NativeTooltip>包裹住
const slots = defineSlots()

if (slots?.default?.().length > 1) {
  logger.warn('NativeTooltip only support one slot.')
}

function updateTooltipContent(content: string) {
  const defaultSlot = slots?.default?.();
  if (defaultSlot) {
    const slotElement = defaultSlot[0]?.el
    // 检查插槽第一个子节点是否为DOM元素
    if(slotElement && slotElement instanceof HTMLElement) {
        // 给slot插槽设置其 title
      slotElement.title = content;
    }
  }
}

onMounted(()=> updateTooltipContent(props.content))

watch(()=>props.content, (val)=> updateTooltipContent(val));
</script>

<template>
  <template v-if="slots.default()[0].el">
    <!-- 子元素是普通 HTML 元素，直接渲染slot -->
    <slot></slot>
  </template>
  <template v-else>
    <!-- 如果是组件，则先用span显示组件名，再将其子el的title正确渲染到slot中 -->
    <span :title="content">
      <slot></slot>
    </span>
  </template>
</template>
```


### 在 TitleBar & NavBar & ThemeSwitcher 使用提示框
`TitleBar.vue`
```html
    <native-tooltip :content="t('window.minimize')">
        <button>
          <iconify-icon />
        </button>
    </native-tooltip>
```
`NavBar.vue`
```html
        <native-tooltip :content="t('main.sidebar.settings')">
            <iconify-icon icon="material-symbols:settings-outline"/>
        </native-tooltip>
```
`ThemeSwitcher.vue`
```vue
<script>
    const { themeTooltip } = useThemeMode();
</script>

<template>
  <native-tooltip :content="themeTooltip">
    <iconify-icon/>
  </native-tooltip>
</template>
```
设置：随着主题改变而改变提示框文本与样式。
```ts
// renderer/hooks/useThemeMode.ts

const tooltipMap = new Map([
  ['system', 'settings.theme.system'],
  ['light', 'settings.theme.light'],
  ['dark', 'settings.theme.dark'],
])

export function useThemeMode() {
//   ...
  const themeTooltip = computed(() => t(tooltipMap.get(themeMode.value) || 'settings.theme.system'));
}

```


## 对话框 aside 宽度动态调整
写一个组件 `ResizeDivider` 任意调节其宽度：
```vue
<script setup lang="ts">
interface Props {
  direction: 'horizontal' | 'vertical';
  valIsNagetive?: boolean;
  size: number;
  maxSize: number;
  minSize: number;
}

interface Emits {
  (e: 'update:size', size: number): void;
}

defineOptions({ name: 'ResizeDivider' });

const props = withDefaults(defineProps<Props>(), {
  valIsNagetive: false,
})
const emit = defineEmits<Emits>();

const size = ref(props.size);

let isDragging = false;
let startSize = 0;
let startPoint = { x: 0, y: 0 };

function startDrag(e: MouseEvent) {
  isDragging = true;

  startPoint.x = e.clientX;
  startPoint.y = e.clientY;

  startSize = size.value;

  document.addEventListener('mousemove', handleDrag);
  document.addEventListener('mouseup', stopDrag);
}

function stopDrag() {
  isDragging = false;
  document.removeEventListener('mousemove', handleDrag);
  document.removeEventListener('mouseup', stopDrag);
}

function handleDrag(e: MouseEvent) {
  if (!isDragging) return;

//   判断正反向拖拽
  const diffX = props.valIsNagetive ? startPoint.x - e.clientX : e.clientX - startPoint.x;
  const diffY = props.valIsNagetive ? startPoint.y - e.clientY : e.clientY - startPoint.y;

  if (props.direction === 'horizontal') {
    size.value = Math.max(props.minSize, Math.min(props.maxSize, startSize + diffY));
    emit('update:size', size.value);
    return
  }
  size.value = Math.max(props.minSize, Math.min(props.maxSize, startSize + diffX));
  emit('update:size', size.value);
}

watchEffect(() => size.value = props.size);
</script>

<template>
  <div class="bg-transparent z-[999]" :class="direction" @click.stop @mousedown="startDrag"></div>
</template>

<style scoped>
.vertical {
  width: 5px;
  height: 100%;
  cursor: ew-resize;
}

.horizontal {
  width: 100%;
  height: 5px;
  cursor: ns-resize;
}
</style>
```
应用到 App 中：
```vue
<template>
  <n-config-provider class="h-full w-[100vw] flex text-tx-primary">
    <aside class="sidebar h-full flex flex-shrink-0 flex-col" :style="{ width: sidebarWidth + 'px' }">
      <div class="flex-auto flex">
        <nav-bar />
        <div class="flex-auto">
          conversation-list
        </div>
      </div>
    </aside>
    <!-- 动态调节 -->
    <resize-divider direction="vertical" v-model:size="sidebarWidth" :max-size="800" :min-size="320" />
    <div class="flex-auto">
      <title-bar>
        <drag-region class="w-full" />
      </title-bar>
      Main
    </div>
  </n-config-provider>
</template>
```