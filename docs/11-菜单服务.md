# 菜单服务 `MenuService`

## 主进程中注册菜单服务实例
通过 `Map` 存储菜单模板，通过 `ipcMain` 监听 `showMenu` 事件，根据传入的 `menuId` 展示对应菜单。
```ts
import { ipcMain, Menu, type MenuItemConstructorOptions } from 'electron';
import { IPC_EVENTS } from '../../common/constants';
import { cloneDeep } from '../../common/utils';
import logManager from './LogService';

// Menu.buildFromTemplate()

let t = (val: string | undefined) => val

class MenuService {
  private static _instance: MenuService;
  private _menuTemplate: Map<string, MenuItemConstructorOptions[]> = new Map();
  private _currentMenu?: Menu = void 0;

  private constructor() {
    this._setupIpcListener();
    this._setupLanguageChangeListener();
    logManager.info('MenuService initialized successfully.');
  }

  private _setupIpcListener() {
    // showMenu的onClose，点击则关闭菜单，设置Promise的resolve为true，evoke就有返回值
    ipcMain.handle(IPC_EVENTS.SHOW_CONTEXT_MENU, (_, menuId, dynamicOptions?: string) => new Promise((resolve) => this.showMenu(menuId, () => resolve(true), dynamicOptions)))
  }

  private _setupLanguageChangeListener() {
    //  :todo   重置i18n的t函数
    // configManager.onConfigChange((config)=> {
      // if(language changed)

      // t = 
    // })
  }

  public static getInstance() {
    if (!this._instance)
      this._instance = new MenuService();
    return this._instance;
  }

//   注册对应对话菜单
  public register(menuId: string, template: MenuItemConstructorOptions[]) {
    this._menuTemplate.set(menuId, template);
    return menuId;
  }

//   展示对应菜单，onClose关闭菜单方法，dynamicOptions动态菜单项
  public showMenu(menuId: string, onClose?: () => void, dynamicOptions?: string) {
    if (this._currentMenu) return;

    const template = cloneDeep(this._menuTemplate.get(menuId));

    if (!template) {
      logManager.warn(`Menu ${menuId} not found.`);
      onClose?.();
      return;
    }

    let _dynamicOptions: Array<Partial<MenuItemConstructorOptions> & { id: string }> = [];
    // 解析动态参数
    try {
      _dynamicOptions = Array.isArray(dynamicOptions) ? dynamicOptions : JSON.parse(dynamicOptions ?? '[]');
    } catch (error) {
      logManager.error(`Failed to parse dynamicOptions for menu ${menuId}: ${error}`);
    }

// 翻译菜单
    const translationItem = (item: MenuItemConstructorOptions): MenuItemConstructorOptions => {
        // 有子菜单则递归调用
      if (item.submenu) {
        return {
          ...item,
          label: t(item?.label) ?? void 0,
          submenu: (item.submenu as MenuItemConstructorOptions[])?.map((item: MenuItemConstructorOptions) => translationItem(item))
        }
      }
      return {
        ...item,
        label: t(item?.label) ?? void 0
      }
    }

    // 对菜单进行本地化处理
    const localizedTemplate = template.map(item => {
        // 若动态参数不是数组 || 数组为空，则直接返回翻译后的菜单项
      if (!Array.isArray(_dynamicOptions) || !_dynamicOptions.length) {
        return translationItem(item);
      }

    //   匹配对应id的动态参数
      const dynamicItem = _dynamicOptions.find(_item => _item.id === item.id);

      if (dynamicItem) {
        const mergedItem = { ...item, ...dynamicItem };
        return translationItem(mergedItem);
      }

    //   子菜单递归处理
      if (item.submenu) {
        return translationItem({
          ...item,
          submenu: (item.submenu as MenuItemConstructorOptions[])?.map((__item: MenuItemConstructorOptions) => {
            const dynamicItem = _dynamicOptions.find(_item => _item.id === __item.id);
            return { ...__item, ...dynamicItem };
          })
        })
      }

      return translationItem(item);
    })

    const menu = Menu.buildFromTemplate(localizedTemplate);

    this._currentMenu = menu;

    menu.popup({
        // 在外部有点击，都会执行cb，onClose
      callback: () => {
        this._currentMenu = void 0;
        onClose?.();
      }
    })
  }

//   删除特定菜单
  public destroyMenu(menuId: string) {
    this._menuTemplate.delete(menuId);
  }

//   清空所有菜单
  public destroyed() {
    this._menuTemplate.clear();
    this._currentMenu = void 0;
  }
}

export const menuManager = MenuService.getInstance();
export default menuManager;
```


## 深浅拷贝方法
 - 深拷贝：递归拷贝每个元素后返回新数组；   
 - 浅拷贝：只拷贝第一层元素，不递归；
```ts
// common/utils.ts

export function cloneDeep<T>(obj: T): T {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(item => cloneDeep(item)) as T;
  }

  const clone = Object.assign({}, obj);
  for (const key in clone) {
    if (Object.prototype.hasOwnProperty.call(clone, key)) {
      clone[key] = cloneDeep(clone[key]);
    }
  }
  return clone;
}

export function simpleCloneDeep<T>(obj: T): T {
  try {
    return JSON.parse(JSON.stringify(obj));
  } catch (error) {
    console.error('simpleCloneDeep failed:', error);
    return obj;
  }
}
```